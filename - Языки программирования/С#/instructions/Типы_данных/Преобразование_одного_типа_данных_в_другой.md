`явное приведение` - для близких по смыслу
`НЕ явное приведение`
`явное преобразование` - когда не можем напрямую привести один тип к другому
`НЕ явное преобразование`


`примеры НЕ явного приведения`
```csharp
string s = 1;
int i = s; // будет ОШИБКА

int j = 5;
double d = j; // ошибки НЕ будет
// но в обратную сторону
int k = d; // будет ОШИБКА

// потому что:
byte b = 42; // возможные значения от 0 до 255
int i = b; // возможные значения от -2 миллиардов до 2 миллиардов
// поэтому компилятор не дурак может перекладывать байтовое значение в интовое, т.к. уместится
// НО в обратную сторону это не работает
int i = 5;
int j = 2048;
byte b = i; // ошибка // хоть i = 5 и попадает в байт, но это не гарантированно, компилятор не уверен
byte bb = j; // тоже ошибка
```

`чтобы выполнить приведение из большего типа в меньший, используется явное приведение`
```csharp
int i = 5;
// оно задаётся с помощью указания типа переменной в скобках перед переменной
// ошибки НЕ будет
byte b = (byte)i; // программист говорит "Да, я уверен, что данные уместятся в байт, ошибки не будет, вся ответственность на мне"

// и так тоже НЕ будет ошибки
int j = 2048;
byte bb = (byte)j; 

// если проверить
Console.WriteLine(bb); // будет лежать 0
Console.ReadLine();

# Суть в том, что компилятор не сообщит об ошибке. Нужно быть осторожным с этим.
// если 
int j = 2048; // в byte bb лежит 0 
int j = 2049; // в byte bb лежит 1  
int j = 2047; // в byte bb лежит 255 

// Что происходит:
// в байте возможные значения от 0 до 255
// исчисление ходит по кругу 0, 1, 2, 3 ... до 255 (с 0 = 256 значений)

// 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14 ... 255 // первый круг
// 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14 ... 255 // в int счёт тоже начинается с 0

//  0    1    2    3    4    5  ... 255 // далее новый круг
// 256  257  258  259  260  261 ... 511  // в int счёт продолжается дальше по счёту

//  0    1    2    3    4    5  ... 255 // новый круг
// 512  513  514  515  516  517 ... 767 
        
// 8 кругов // 0 + 255 + 256 * 7 = 2047
//   0     1     2     3     4     5  ... 255 // восьмой круг
// 1791  1792  1793  1794  1795  1796 ... 2047 
```

?? в Java ?? 
#  диапазон байт от -128 до 127  ->  0 - это положительное значение
#  -128  - это 128 отрицательных значений
#  127  - это 128 положительных значений (0 тоже значение)

Не всегда возможно привести один тип в другой
например:
```csharp
string s = "2048";
int jojo = (int)s; // ошибка
```


Тогда нужно делать преобразование переменной (выполняет дополнительные проверки)
выполняется с помощью специального класса `Convert`
`явное ПРЕОБРАЗОВАНИЕ`
```csharp
string s = "2048";
int jojo = Convert.ToInt32(s);

// если в строке написать бред
string s = "lihsfhle";
int jojo = Convert.ToInt32(s); // то будет ошибка о невозможности конвертации
```


`другой способ для явного преобразования`
```csharp
string s = "2048";
int jojo = Int32.Parse("2048"); // правильнее использовать так

int jojo = int.Parse("2048"); // но на крайний случай можно использовать так

int jojo = int.TryParse("2048"); // метод TryParse более правильный и его нужно использовать чаще
// для его использования необходимо знать условные операторы
```


`НЕ явное ПРЕОБРАЗОВАНИЕ`
происходит при работе со строками
```csharp
int i = 1; // объявляем переменную
// метод tostring - метод преобразования, приведения, конвертации в строку 
// есть абсолютно у каждого объекта в C#
// следовательно всегда и всё можно преобразовать в строковый формат
// компилятор видя что мы складываем строку и целое число, 
// понимает, что число нужно преобразовать в строку и склеить эти 2 строки
string s = "str" + i; // потом объединяем со строкой
string s = "str" + i.ToString(); // так можно, но не обязательно, т.к. с этим методом идёт уже явное преобразование в строку
int jojo = Convert.ToInt32(s);

// если в строке написать бред
string s = "lihsfhle";
int jojo = Convert.ToInt32(s); // то будет ошибка о невозможности конвертации
```


```csharp
bool b = true;
string s = b; // ошибка  
string s = b.ToString(); // нужно так

// в обратную сторону
string s = true;   
bool b = s; // ошибка
bool b = (bool)s; // ошибка
bool b = Convert.ToBoolean(s); // нужно так
// только чрез конверт либо true либо false 
```



```csharp
int result
if(int.TryParse("123", out int result)) // если получится выполнить эту строку
{
    // в консоль выйдет результат
    Console.WriteLane(reault); // а если не получится выполнить строку выше, 
    // этот блок выполняться не будет
    //своего рода проверка на корректность
}
``` 

`чтобы получить данные из консоли`
```csharp
if(int.TryParse((Console.ReadLine)"123", out int result)) // если получится выполнить эту строку
{
    // в консоль выйдет результат
    Console.WriteLane(reault); // а если не получится выполнить строку выше, 
    // этот блок выполняться не будет
    //своего рода проверка на корректность
}
``` 